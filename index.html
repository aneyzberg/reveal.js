<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/white.css">
  <link rel="stylesheet" href="lib/css/atom-one-light.css" />

  <!-- Theme used for syntax highlighting of code -->
  <!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section class="center" data-background-color="#025A6E">
        <h2>Crypto + Concurrency</h2>
        <p style="font-size: 30px">Anna Neyzberg • @ANeyzb • anna@carbonfive.com</p>
      </section>

      <section>
        <h3>About me:</h6>
          <ul>
            <li>I co-founded ElixirBridge founders</li>
          </ul>

          <img src="lib/images/rockclimbing.jpg" width="400px" />
      </section>

      <section class="center">
        <div>What I want to talk about today?</div>
      </section>

      <section class="center">
        <div>
          <ul>
            <li>What is Bitcoin/Blockchain</li>
            <li>How does it work?</li>
            <li>Why try and build it in elixir</li>
          </ul>
        </div>

      </section>



      <section class="center">
        <h3>What is Bitcoin?</h3>
      </section>

      <section class="center">
        <h3>Bitcoin uses blockchain to implement decentralized leger for payemnts</h3>
      </section>

      <section class="center">
        <h3>It is a secure semi-annonymous
          <br/> store of value</h3>
      </section>

      <section class="center">
        <h3>What is value?</h3>
      </section>

      <section class="center">
        <img src="lib/images/us_dollar.jpg" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 187px; padding-bottom: 15px;">credit: https://www.slideshare.net/AsharAzam/exchange-rates-international-financial-system</div>
        <aside class="notes">
          <ul>
            "create something scarce" "disincentive to buy into a system that grows in supply" "also people need to be using it" "paying
            taxes"
          </ul>
          <li>gollar has value because you can pay taxes</li>
          <li>people are willing to use it, believe u.s economy is going to keep working</li>
          <li>fiat's value is not about instrinsic value, but about making a guess about the future</li>
        </aside>
      </section>



      <section class="center">
        <div>"Money is any clearly identifiable object of value that is generally accepted as payment for goods and services and
          repayment of debts within a market, or which is legal tender within a country. "</div>
        <div class="credit" style="padding-right: 22px">credit: https://en.wikipedia.org/wiki/History_of_money</div>
        <aside class="notes">
          <ul>
            <li>source of value you can use to get other things of value</li>
            <li>unit of account (we can denominate value)</li>
            <li>medium of exchange</li>
            <li>store of value</li>
            <li>cash - intrinsically valuable good that allows you to pay for material goods</li>
            <li>credit - allows you to determine debt</li>
          </ul>
        </aside>
      </section>

      <section class="center">
        <img src="lib/images/value_of_money.jpg" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://www.youtube.com/watch?v=XNu5ppFZbHo</div>
      </section>




      <!-- <section>
          <h1> 1/h1>
        <aside class="notes">
          <ul>


          </ul>
        </aside>
      </section>

      <section>how can you create non-collateralized cash that is still valuable
        <aside class="notes">
          <ul>
              "create something scarce"
              "disincentive to buy into a system that grows in supply"
              "also people need to be using it"
              "paying taxes"
          </ul>
        </aside>
      </section> -->


      <section class="center">
        So Back to Bitcoin
      </section>



      <section class="center">Big idea behind cryptocurrencies...</section>

      <section class="center">
        Do value transfer over the internet
        <br/>
        <br /> that is anonymous and secure
        <aside class="notes">
          <ul>
            <li>first time we have a stoer of value that is comletely digital</li>
            <li>people are willing to use and can excahnge for goods and servces</li>
            <li>it is scarce</li>
          </ul>
        </aside>

      </section>

      <section class="center">
        <h3>Cryptography</h3>

        <img src="lib/images/history_of_crypto.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 187px; padding-bottom: 15px;">credit: https://commons.wikimedia.org/wiki/File:SIGABA-patent.png</div>
        <aside class="notes">
          <ul>
            <li>mostly government or military</li>
            <li>before 1970 cryptography mostly govt or military</li>
            <li>military emission till 199</li>
            <li>foretathers of cryptography belived in using cryptography use cryptography to break monopoly of the state</li>
            <li>advent of computers changed things</li>
        </aside>
      </section>


      <section>
        <img src="lib/images/cypher_punks.jpeg" style="width: 500px; margin-top: -16px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 173px; padding-bottom: 15px;">credit: https://medium.com/swlh/cypherpunks-and-the-rise-of-cryptocurrencies-899011538907</div>
        <aside class="notes">
          <ul>
            <li>1992 Cyper Punks Eric Hughes, Timothy C. May and John Gilmore started an organization humorously called cyperhpunks</li>
            mailing list started </li>
            <li>1994 700 subscribers</li>
            <li>1995 Eric Hughes wrote the cypherpunks manifesto online privacy communications - respecting rights of peopel
              to use pseudonyms and maintain anonymity in online world - up to citizens to check govt pwer - your powere
              in anonymity and resistance to censorship - hiding the act of hiding- by hiding you should not be incriminating
              yourself - TNO
            </li>
            <li> PGP and Tor cyperpunk projects</li>
            <li> 2008 crisis central govt has too much power - hyperinflation happens becuase govt prints money</li>
            <li>several early cypherpunk experimented with digital currencies that were not successful, but that Satoshi drew
              inproation from</li>
          </ul>
        </aside>
      </section>

      <section>
        <div>"Privacy is necessary for an open society
          <br/> in the electronic age. ...
          <br/>
          <br/> We cannot expect governments, corporations, or othasher large, faceless organizations to grant us privacy ...
          <br/>
          <br/> Cypherpunks write code. We know that someone has to write software to defend privacy, and ...
          <br/> we're going to write it."</div>
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: Eric Hughes "A Cypherpunk's Manifesto"</div>
      </section>

      <section class="center">
        Many early attempts at digitial currencies failed
      </section>

      <section>
        <img src="lib/images/hash_cash.jpg" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://twitter.com/lopp/status/877548439000817665/div>


          <aside class="notes">
            <ul>
              <li>
                satoshi took inspiration from them
              </li>
            </ul>
          </aside>
          </ul>
          </aside>
      </section>




      <section class="center">
        <div>2008....</div>

        <img src="lib/images/2008_crisis.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: http://www.haraldhau.com/the-role-of-equity-funds-in-the-financial-crisis-propagation/</div>
        <aside class="notes">
          <ul>
            <li>
              talk in the cypherpunk community about the need for an alternative to storing value within the government
            </li>
          </ul>
        </aside>
      </section>

      <section>
        <img src="lib/images/bitcoin.jpg" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://www.istockphoto.com/photos/bitcoin?excludenudity=true&amp;sort=mostpopular&mp;mediatype=photography&amp;phrase=bitcoin/</div>
      </section>


      <section class="center">
        <div>“With e-currency based on cryptographic proof, without the need to trust a third party middleman, money can be secure
          and transactions effortless.” — Satoshi Nakamoto</div>

        <aside class="notes">
          <ul>
            <li>allows store value outside of governments</li>
            <li>decentarlized</li>
            <li>no single point of failure</li>
            <li>anonymity</li>
            <li>Big idea behind cryptocurrencies, - do value transfer over the internet</li>
            <li>> We can transfer value over the internet</li>
          </ul>
        </aside>
      </section>

      <section class="center">
        <h3>How does it work?</h3>
        <img src="lib/images/block_chain.jpeg" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://hackernoon.com/ecommerce-on-the-blockchain-part-two-895e006b1bb3</div>
        <aside class="notes">

      </section>

      <section class="center">
        <img src="lib/images/blockchain_network.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://blockgeeks.com/guides/what-is-blockchain-technology/</div>

        <aside class="notes">
          <ul>
            <li>decentralized</li>
            <li>each node has a copy of the entire blockchain</li>
            <li>when a transaction is sent from one node to another - </li>
            <li>tenets we talked about earlier - decentralized </li>
            <li>when two people want to exchage bitcoin, and encrypted record of transaction is sent to all other nodes in the
              network</li>
            <li>nodes are able to verify the transaction - when enough nodes agree on authenticity of transaction it is added
              to the leger</li>
            <li>anonymity</li>
          </ul>
        </aside>
      </section>


      <section class="center">
        <img src="lib/images/block_chain_1.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://medium.com/@micheledaliessi/how-does-the-blockchain-work-98c8cd01d2ae</div>

        <aside class="notes">
          <ul>
            <li>A blockchain is a distributed database that maintains a continuously growing list of data records that cannot
              be tampered.</li>
            <li>A blockchain consists of a number of blocks that are linked with each other with each block linked with its previous
              block.</li>
            <li>and, each block consists of a batch of timestamped transactions and a hash of previous block. As the blocks are
              linked with each other forming a chain, hence the name of the database.</li>
            <li>anonymity</li>
            <li>it is very difficult to corrup the leger</li>
            <li>uses sha256 encrypts it down </li>
          </ul>
        </aside>
      </section>


      <section class="center">
        <p>"A gossip protocol[1] is a procedure or process of computer-computer communication that is based on the way social
          networks disseminate information or how epidemics spread.</p>
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://blockgeeks.com/guides/what-is-blockchain-technology/</div>


        <aside class="notes">
          <ul>
            <li>part of the Bitcoin experiment is the underlying blockchain technology as a tool of distributed consensus</li>
          </ul>
        </aside>
      </section>

      <section>
        <img src="lib/images/gossip-visualization.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://dreamonward.com/project/gossip-visualization/</div>
      </section>

      <section>
        <img src="lib/images/private_key_encryption.svg" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://blockgeeks.com/guides/what-is-blockchain-technology/</div>
        <aside class="notes">
          <ul>
            <li>single transaction</li>
            <li>
              Assymetric encryption - public key encryption
            </li>
            <li> is any cryptographic system that uses pairs of keys: public keys which may be disseminated widely, and private
              keys which are known only to the owner. </li>
          </ul>
        </aside>
      </section>


      <section class="center">
        <img src="lib/images/transaction.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://blockgeeks.com/bitcoin-transactions/</div>
      </section>


      <section class="center">
        <img src="lib/images/utxo.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: http://blog.coinkite.com/post/88396049981/flex-liquidity-smart-utxo-management/</div>

      </section>

      <section>
        <img src="lib/images/block_chain_explanation.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://computersecuritypgp.blogspot.com/2016/05/what-is-blockchain.html</div>

        <aside class="notes">
          <ul>
            <li>A blockchain is a distributed database that maintains a continuously growing list of data records that cannot
              be tampered.</li>
            <li>A blockchain consists of a number of blocks that are linked with each other with each block linked with its previous
              block.</li>
            <li>and, each block consists of a batch of timestamped transactions and a hash of previous block. As the blocks are
              linked with each other forming a chain, hence the name of the database.</li>
            <li>anonymity</li>
            <li>it is very difficult to corrup the leger</li>
            <li>uses sha256 encrypts it down </li>
            <li>enforces order, no global time</li>
            <li>use blockchain to force an ordering of transactions</li>
          </ul>
        </aside>
      </section>


      <section class="center">


        <img src="lib/images/proof-of-work.jpg" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://www.blockchain-council.org/blockchain/what-is-proof-of-work/</div>
        <aside class="notes">
          <ul>
            <li>
              hard to reach consensus when cheap to add blocks
          </ul>
        </aside>
      </section>

      <section class="notes">
        <img src="lib/images/block_chain_explanation.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://computersecuritypgp.blogspot.com/2016/05/what-is-blockchain.html</div>

      </section>

      <section class="center">

        <div>It provided a simple and moderately effective consensus algorithm, allowing nodes in the network to collectively
          agree on a set of canonical updates to the state of the Bitcoin ledger.</div>
      </section>


      <section class="center">
        Solves the political problem of deciding who gets to influence the consensus



        <aside class="notes">
          <ul>
            <li>Blocks get added through the chain by mining</li>
            <li>proof of work</li>
            <li>In bitcoin the service string is encoded in the block header data structure, and includes a version field, the
              hash of the previous block, the root hash of the merkle tree of all transactions in the block, the current
              time, and the difficulty.</li>
            <li>Version (4 bytes) Hash of the previous block, thus making a chain of block (32 bytes) Merkle root, the tree of
              transactions' reference (32 bytes) Timestamp, number of seconds since 1970-01-01 00:00 (4 bytes) Bits, a representation
              of the networks current difficulty (4 bytes) Nonce, incremented when mining (4 bytes)</li>
            <li>so when miners mine a block - they use the blockheader and a nonce - and a nonce (randomg value) that is hashed
              to try and find proof of work</li>
            <li>A blockchain consists of a number of blocks that are linked with each other with each block linked with its previous
              block.</li>
            <li>and, each block consists of a batch of timestamped transactions and a hash of previous block. As the blocks are
              linked with each other forming a chain, hence the name of the database.</li>
            <li>once found block, it communicates to network. If block is valid other nodes add it, and</li>
            <li>incentivizes nodes to be good actors</li>
            <li>incentives people to contribute</li>
            <li>The mechanism behind proof of work was a breakthrough in the space because it simultaneously solved two problems.
              <li> It does this by substituting a formal barrier to participation, such as the requirement to be registered as
                a unique entity on a particular list, with an economic barrier - the weight of a single node in the consensus
                voting process is directly proportional to the computing power that the node brings.</li>
          </ul>
        </aside>
      </section>


      <section class="center">
        <h3>Nakomoto Concensus</h3>
        <img src="lib/images/nakomoto_consensus.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://blockgeeks.com/guides/blockchain-consensus/</div>
        <aside class="notes">
          <ul>
            <li>
              Nodes agree to that to build of the longest block chain
            </li>
            <li>so when node mines block it will gossip it out ot the network that am working off of chain h - and assuming block
              is valid, nodes will all build off block height h</li>
            <li>after 6 lbocks pretty sure its valid</li>
          </ul>
        </aside>

      </section>


      <section class="center">
        <img src="lib/images/elixir_logo.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: http://brunakochi.com/projects/elixir.html</div>
        <aside class="notes">
          <ul>
            <li>So why think about this in the context of Elixir?</li>
            <li>so given this I tried to build a crypotcurrency in eliixr. Before I talk to you about what that experience was
              like, I want to review teh properties of elixir that make it such good fit</li>
          </ul>

        </aside>
      </section>


      <section class="center">
        <div>Bitcoin uses blockchain to implement decentralized leger for payments</div>
      </section>

      <section class="center">
        <div>Nodes send messages to the network using a gossip protocol</div>
      </section>


      <section class="center">
        <div>So we need a decentralized system that is concurrent, that communicates via message passing</div>
      </section>

      <section class="center">
        <div>Sound familiar?</div>
      </section>

      <section class="center" b>
        Let's take a quick look at how
        <br /> message passing works in elixir
      </section>


      <section class="center">
        <h2>Processes</h2>
        <aside class="notes">
          <ul>
            <li>how does work get down in elixir</li>
            <li>all code in elixir runs inside of processes</li>
            <li>processes are isolated from each other, run concurrent to one another, and communicate via message passing. </li>
            <li>small programs communciate to each other via message passing, supe rlight weight</li>
            <li>they seem like native threads but are simpler, and can have thousands of processes running concurrently</li>
            <li>thanks to the erlang VM, our processes are working across all your CPU's so you are maximizng efficiency.</li>
          </ul>

        </aside>
      </section>

      <section data-background-color="#fffff">
        <pre class="elixir" style="font-size: 1em;" data-background-color="#fffff">
              <code data-trim style="overflow: hidden; overflow-x: none;" data-noescape>

                defmodule Example do
                    subtract(a, b) do
                    a - b
                  end
                end


                iex> Example.subtract(3, 2)
                1
                :ok
            </code></pre>
      </section>


      <section data-background-color="#fffff">
        <pre class="elixir" style="font-size: 1em; margin: 150px 0"><code data-trim>
                spawn(Example, :subtract, [3, 2])
                1
                #PID<0.80.0>
            </code>

            </pre>
        <aside class="notes">
          <ul>
            <li>easiest way to create a process is to call spawn</li>
            <li>spawn takes an anonymous or named function</li>
            <li>spawn returns a process Identifier or PID</li>
          </ul>

        </aside>

      </section>


      <section class="center">
        <h2>Message passing</h2>
        <img src="lib/images/process_message_passing.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
        <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: http://benjamintan.io/blog/2013/06/25/elixir-for-the-lazy-impatient-and-busy-part-2-processes-101/</div>


        <aside class="notes">
          <ul>
            <li>processes communicate by passing messages</li>
            <li>here are two main components to this: send/2 and receive</li>
            <li> send function allows us to send to PIDs and receive function allows us to match messsges</li>
          </ul>
        </aside>
      </section>

      <section data-background-color="#fffff">

        <pre class="elixir" style="font-size: 18px">
                <code style="overflow: hidden; overflow-x: none;" data-trim>
                    defmodule Greet do
                      def by_name do
                        receive do
                          {:name, name} -> IO.puts("Hello #{name}")
                        end

                        by_name
                      end
                    end

                    iex> pid = spawn(Greet, :by_name, [])
                    #PID<0.108.0>

                    iex> send pid, {:name, "Ben"}
                    "Hello Ben"
                    {:name, "Ben"}

                    iex> send pid, :ok
                    :ok
                </code>
              </pre>

        <aside class="notes">
          <ul>
            <li>create a process</li>
            <li>pass in our arguemtne which is a tuple of name and teh string "bem</li>
            <li>if matches it recieve expected string "hello ben"</li>
          </ul>
        </aside>
      </section>

      <section data-background-color="#fffff">
        <pre class="elixir" style="font-size: .7em">
                <code style="overflow: hidden; overflow-x: none;" data-trim>
                    defmodule Greet do
                      def by_name do
                        receive do
                          {:name, name} -> IO.puts("Hello #{name}")
                        end

                        by_name
                      end
                    end
                </code>
              </pre>

        <aside class="notes">
          <ul>
            <li>create a process</li>
            <li>pass in our arguemtne which is a tuple of name and teh string "bem</li>
            <li>if matches it recieve expected string "hello ben"</li>
          </ul>
        </aside>
      </section>

      <section data-background-color="#fffff">

        <pre class="elixir" style="font-size: 1em">
              <code style="overflow: hidden; overflow-x: none;" data-trim>
                  iex> pid = spawn(Greet, :by_name, [])
                  #PID<0.108.0>

                  iex> send pid, {:name, "Ben"}
                  "Hello Ben"
                  {:name, "Ben"}

                  iex> send pid, :ok
                  :ok
              </code>
            </pre>

        <aside class="notes">
          <ul>
            <li>create a process</li>
            <li>pass in our arguemtne which is a tuple of name and teh string "bem</li>
            <li>if matches it recieve expected string "hello ben"</li>
          </ul>
        </aside>
      </section>


      <section class="center">
        <div>Process Linking &amp; Process Monitoring
          <div>
      </section>


      <section class="center" data-background-color="#fffff">
        <pre class="elixir" style="font-size: .8em; top: 0;">
                  <code data-trim>
                    defmodule Connection do
                      def explode, do: exit(:kaboom)
                    end

                    iex> spawn(Example, :explode, [])
                    #PID<0.66.0>

                    iex> spawn_link(Example, :explode, [])
                    ** (EXIT from #PID<0.57.0>) evaluator
                       process exited with reason: :kaboom

                  </code>
                </pre>
        <aside class="notes">
          <ul>
            <li>other things that we can do with processes</li>
            <li>problen with spawn is we don't know if our process crashes</li>
            <li>this allows our processes to recieve exit notifications from each other</li>
            <li>now we don't want to our current process to die, we can trap the exit messages and handle them so current process
              does not die </li>
          </ul>
        </aside>
      </section>


      <section class="center" style="top: 0px" data-background-color="#fffff">
        <h4>Agents</h4>

        <pre class="elixir" style="font-size: .6em; width: 100%;">
                <code data-trim>
                  iex> {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
                  {:ok, #PID<0.65.0>}

                  iex> Agent.update(agent, fn (state) -> state ++ [4, 5] end)
                  :ok

                  iex> Agent.get(agent, &(&1))
                  [1, 2, 3, 4, 5]

                </code>
              </pre>
        <aside class="notes">
          <ul>
            <li>Agents are an abstraction around background processes maintaining state. We can access them from other processes
              within our application and node. The state of our Agent is set to our function’s return value:
            </li>
            <li>agents are actually what we are going to use to store the state of our blockchain</li>
          </ul>
        </aside>
      </section>


      <section class="center">
        Back to BlockChain

        <aside class="notes">
          <ul>
            <li>so we saw some abstractions for concurrency around message passing and storing state</li>
            <li>w can run mutiple processes at teh same time, we can store state in processes and communicate asynchronously
              via messages</li>
            <li>no we'll take a look at how elixir and especially Erlan allows us to create </li>
            <li>yet to build a blockshain network, we want greater conrtol of the concurrency and message passing</li>
            <li> We want something to manage that more complicated behavrio</li>
          </ul>
        </aside>
      </section>

      <section class="center">
        <h3>OTP</h3>
        <aside class="notes">
          <ul>
            <li>When we think about how to build concurrent applications, and how to deal with monitorin, and timeouts etc, adn
              servers, there are things to think about.</li>
            <li>OTP framework takes care of this by grouping these essential practices into a set of libraries that have been
              carefully engineered and battle-hardened over years.</li>
            <li>The OTP framework is also a set of modules and standards designed to help you build applications. </li>
            <ul>
        </aside>
      </section>

      <section class="center">
        <h3>So let's start building</h3>
      </section>

      <section class="center">
        <h1>Transactions</h1>
      </section>

      <section class="center" data-background-color="#fffff">
        <pre class="elixir" style="font-size: 12px">
                    <code data-trim>
                      defmodule Gossip.Transaction do
                        alias Gossip.Transaction
                        alias Gossip.RSA


                        defstruct to: '', from: '', amount: 0, signature: ''

                        def new_transaction(to, from, amount, private_key) do
                          %Transaction{
                            to: to,
                            from: from,
                            amount: amount,
                            signature: sign(private_key, {to, from, amount})
                            }
                        end

                        def sign(priv_key, {to, from, amount}) do
                          hash = :crypto.hash(:sha256, [to,  amount])
                          {:ok, signature} = ExPublicKey.sign(hash, priv_key)
                          signature
                        end

                        def valid?(pub_key, %Transaction{to: to, from: from, amount: amount, signature: signature}) do
                          message = :crypto.hash(:sha256, [to, amount])
                          {:ok, valid}  = ExPublicKey.verify(message, signature, from)
                        end
                      end

                    </code>
                  </pre>
        <aside class="notes">
          <ul>
            <li>explain transactions in blockchian</li>
          </ul>
        </aside>
      </section>


      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .6em; margin: 0 0">
                    <code data-trim style="max-height: none">
                      defmodule Gossip.Transaction do
                        alias Gossip.Transaction
                        alias Gossip.RSA


                        defstruct to: '', from: '', amount: 0, signature: ''

                        def new_transaction(to, from, amount, private_key) do
                          %Transaction{
                            to: to,
                            from: from,
                            amount: amount,
                            signature: sign(private_key, {to, from, amount})
                            }
                        end
                      end

                    </code>
                  </pre>
        <aside class="notes">
          <ul>
            <li>explain transactions in blockchian</li>
          </ul>
        </aside>
      </section>


      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .6em; margin: 0 0">
                    <code data-trim style="max-height: none">
                      defmodule Gossip.Transaction do
                        alias Gossip.Transaction
                        alias Gossip.RSA
                        ...

                        def sign(priv_key, {to, from, amount}) do
                          hash = :crypto.hash(:sha256, [to,  amount])
                          {:ok, signature} = ExPublicKey.sign(hash, priv_key)
                          signature
                        end
                      end

                    </code>
                  </pre>
        <aside class="notes">
          <ul>
            <li>explain transactions in blockchian</li>
          </ul>
        </aside>
      </section>

      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%">
                    <code data-trim style="max-height: none; overflow: hidden;">
                      defmodule Gossip.Transaction do
                        alias Gossip.Transaction
                        alias Gossip.RSA
                        ...

                        def valid?(pub_key, %Transaction{to: to, from: from, amount: amount, signature: signature}) do
                          message = :crypto.hash(:sha256, [to, amount])
                          {:ok, valid}  = ExPublicKey.verify(message, signature, from)
                        end
                      end

                    </code>
                  </pre>
        <aside class="notes">
          <ul>
            <li>explain transactions in blockchian</li>
          </ul>
        </aside>
      </section>




      <section class="center">
        We know we need to somehow build a chain of blocks
      </section>


      <section class="center">
        So let's start with a single block
      </section>



      <section class="center" data-background-color="#fffff">
        <pre class="elixir" style="font-size: 12px">
                      <code data-trim>
                          defmodule Block do
                            defstruct nonce: nil, previous_hash: nil, transaction: nil
                            ....

                            def create({:previous_hash, previous_hash, work_factor}, transaction) do
                              hash_info = mint(previous_hash, work_factor)
                              %Block{nonce: hash_info.nonce, previous_hash: previous_hash, transaction: transaction}
                            end

                            def mint(previous_hash, work_factor) do
                              nonce = 0
                              .....
                              create_hash(previous_hash, nonce, matcher)
                            end

                            def create_hash(previous_hash, nonce, matcher) do
                              stringified_nonce = Integer.to_string(nonce)
                              hash =  :crypto.hash(:sha256, [previous_hash, stringified_nonce])

                              #this function will recursively call itself till it solves the puzzle
                              .....
                            end
                          ....
                        end
                      </code>
                    </pre>

        <aside class="notes">
          <ul>
            <li>each block will have a single transaction</li>
            <li>essentially we have a module, that creates and manipulate a Struct that has a nonce, the hash generated by the
              previous block, and a trnsaction</li>
            <li>we receive a transaction, and create a block based on the workfactor</li>
            <li>work in progress - given that the determing the work factor takes time, i haven't done it year, but you might
              think that you could easily leverage - how easily processes can run concurrently, to have that hashing potentially
              happen at the same time by multiple processses to make hashing more efficient</li>
          </ul>
        </aside>
      </section>

      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                          defmodule Block do
                            defstruct nonce: nil, previous_hash: nil, transaction: nil
                            ....

                            def create({:previous_hash, previous_hash, work_factor}, transaction) do
                              hash_info = mint(previous_hash, work_factor)
                              %Block{
                                nonce: hash_info.nonce,
                                previous_hash: previous_hash,
                                transaction: transaction
                              }
                            end
                          ....
                        end
                      </code>
                    </pre>

        <aside class="notes">
          <ul>
            <li>each block will have a single transaction</li>
            <li>essentially we have a module, that creates and manipulate a Struct that has a nonce, the hash generated by the
              previous block, and a trnsaction</li>
            <li>we receive a transaction, and create a block based on the workfactor</li>
            <li>work in progress - given that the determing the work factor takes time, i haven't done it year, but you might
              think that you could easily leverage - how easily processes can run concurrently, to have that hashing potentially
              happen at the same time by multiple processses to make hashing more efficient</li>
          </ul>
        </aside>
      </section>

      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                          defmodule Block do
                            ...
                            def mint(previous_hash, work_factor) do
                              nonce = 0
                              .....
                              create_hash(previous_hash, nonce, matcher)
                            end

                            def create_hash(previous_hash, nonce, matcher) do
                              stringified_nonce = Integer.to_string(nonce)
                              hash =  :crypto.hash(:sha256, [previous_hash, stringified_nonce])

                              #this function will recursively call itself till it solves the puzzle
                              .....
                            end
                          ....
                        end
                      </code>
                    </pre>

        <aside class="notes">
          <ul>
            <li>each block will have a single transaction</li>
            <li>essentially we have a module, that creates and manipulate a Struct that has a nonce, the hash generated by the
              previous block, and a trnsaction</li>
            <li>we receive a transaction, and create a block based on the workfactor</li>
            <li>work in progress - given that the determing the work factor takes time, i haven't done it year, but you might
              think that you could easily leverage - how easily processes can run concurrently, to have that hashing potentially
              happen at the same time by multiple processses to make hashing more efficient</li>
          </ul>
        </aside>
      </section>


      <section class="center">
        <div>Ok, we have a block....How to we create a chain</div>
      </section>

      <section class="center" data-background-color="#fffff">
        <pre class="elixir" style="font-size: 12px">
                      <code data-trim>
                        defmodule Gossip.BlockChain do
                          @work_factor 1
                          @me __MODULE__
                          @block_reward 100

                          defstruct blocks: [], pub_key: nil, priv_key: nil

                          def start_link() do
                            {:ok, pid} = Agent.start_link(&amp;initial_state/0, name: @me)
                          end

                          def child_spec(_opts) do
                            %{
                              id: __MODULE__,
                              start: {__MODULE__, :start_link, []},
                              type: :worker,
                              restart: :permanent,
                              shutdown: 500
                            }
                          end

                          def initial_state do
                            {priv_key, pub_key} = RSA.generate_rsa
                            %BlockChain{blocks: [], priv_key: priv_key, pub_key: pub_key}
                          end
                        end
                      </code>
                    </pre>


        <aside class="notes">
          <ul>
            <li>So we need each node to have a chain of blocks</li>
            <li>so as you can see we have another struct</li>
            <li>now remeber that message identification is all done via cryptography, so each node needs a public nad private
              key</li>
            <li>it iwll only send its pub key, not a security expert or cryptographer</li>
            <li>but there are a couple of other intersting things happend in thsi file</li>
            <li>so where are we storing the state. notice that to start that we have a start link function, that is starting
              an agent</li>
            <li>remember agenst can stor state</li>
            <li>So this module is storing our Block Chain struct as state in our agent process. and we can retreive manipulte
              and update that state</li>
            <li>So we have this background process maintaing our blockchain</li>
            <li>yet how do we know if its up, and what happends if it goes down</li>
            <li>So this is where we go back to some of the Powerful features of OTP</li>
          </ul>
        </aside>
      </section>

      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                        defmodule Gossip.BlockChain do
                          @work_factor 1
                          @me __MODULE__
                          @block_reward 100

                          defstruct blocks: [], pub_key: nil, priv_key: nil
                          ....

                          def initial_state do
                            {priv_key, pub_key} = RSA.generate_rsa
                            %BlockChain{blocks: [], priv_key: priv_key, pub_key: pub_key}
                          end
                        end
                      </code>
                    </pre>


        <aside class="notes">
          <ul>
            <li>So we need each node to have a chain of blocks</li>
            <li>so as you can see we have another struct</li>
            <li>now remeber that message identification is all done via cryptography, so each node needs a public nad private
              key</li>
            <li>it iwll only send its pub key, not a security expert or cryptographer</li>
            <li>but there are a couple of other intersting things happend in thsi file</li>
            <li>so where are we storing the state. notice that to start that we have a start link function, that is starting
              an agent</li>
            <li>remember agenst can stor state</li>
            <li>So this module is storing our Block Chain struct as state in our agent process. and we can retreive manipulte
              and update that state</li>
            <li>So we have this background process maintaing our blockchain</li>
            <li>yet how do we know if its up, and what happends if it goes down</li>
            <li>So this is where we go back to some of the Powerful features of OTP</li>
          </ul>
        </aside>
      </section>


      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                        defmodule Gossip.BlockChain do
                          @work_factor 1
                          @me __MODULE__
                          @block_reward 100

                          def start_link() do
                            {:ok, pid} = Agent.start_link(&amp;initial_state/0, name: @me)
                          end
                          ...
                        end
                      </code>
                    </pre>


        <aside class="notes">
          <ul>
            <li>So we need each node to have a chain of blocks</li>
            <li>so as you can see we have another struct</li>
            <li>now remeber that message identification is all done via cryptography, so each node needs a public nad private
              key</li>
            <li>it iwll only send its pub key, not a security expert or cryptographer</li>
            <li>but there are a couple of other intersting things happend in thsi file</li>
            <li>so where are we storing the state. notice that to start that we have a start link function, that is starting
              an agent</li>
            <li>remember agenst can stor state</li>
            <li>So this module is storing our Block Chain struct as state in our agent process. and we can retreive manipulte
              and update that state</li>
            <li>So we have this background process maintaing our blockchain</li>
            <li>yet how do we know if its up, and what happends if it goes down</li>
            <li>So this is where we go back to some of the Powerful features of OTP</li>
          </ul>
        </aside>
      </section>

      <section class="center">
        <div>Let's add a Supervisor</div>


        <aside class="notes">
          <ul>
            <li>Supervisors are specialized processes with one purpose: monitoring other processes. </li>
            <li>These supervisors enable us to create fault-tolerant applications by automatically restarting child processes
              when they fail.</li>
          </ul>
        </aside>
      </section>

      <section class="center">
        How do we set this up?
      </section>


      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .6em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                            defmodule Application do
                              use Application
                              use Supervisor

                              def start(_type, _args) do
                                Supervisor.start_link([{Gossip.BlockChain, []}],
                                strategy: :one_for_one, name: BlockChain.Supervisor)
                              end
                          end
                        </code>
                      </pre>

        <aside class="notes">
          <ul>
            <li>so in our main application module, we using the supervisor behavior </li>
            <li>the magic happens in our start link function.</li>
            <li>here the supervisor takes a lit of child processes it is supervising, each argument to the list is a tuple with
              name of child process, adn initial arguments to be passed to that process, and a strategy for restarting.
            </li>
            <li>there are many strategies for restarting. in this case, we are saying only restart the failed process.</li>
            <li>So superviosr will call start_link to start its respective child processes</li>
          </ul>
        </aside>
      </section>


      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                            defmodule BlockChain do
                              @work_factor 1
                              @me __MODULE__
                              @block_reward 100

                              ...
                              def child_spec(_opts) do
                                %{
                                  id: __MODULE__,
                                  start: {__MODULE__, :start_link, []},
                                  type: :worker,
                                  restart: :permanent,
                                  shutdown: 500
                                }
                              end
                          end

                        </code>
                      </pre>
        <aside class="notes">
          <ul>
            <li>Now back in our BlockChain module notice two things</li>
            <li>we also have a function called child_spec. This tells the supervisor how to start the blockchain module </li>
            <li>so when it called start link, it will call start which defaults to start_link</li>
            <li>we also tell it how to restart the process - in this case permenent - always restart</li>
          </ul>
        </aside>
      </section>


      <section class="center">
        <div>Supervisors makes fault tolerance easy</div>
      </section>

      <section class="center">
        <div>And fault tolerance is what we want in a distributed blockchain system</div>
      </section>


      <section class="center">
        <div>Let's look at our blockchain module again</div>
      </section>

      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                              defmodule Gossip.BlockChain do
                                ....
                                def add_block(transaction) do
                                  add_new_block(transaction)
                                end
                                ...
                                def add_new_block(transaction) do
                                ..
                                  case Transaction.valid?(pub_key, transaction) do
                                      {:ok, true} ->
                                        # create new block
                                        update_and_retrieve_chain(block)
                                      _ ->
                                        IO.puts "Invalid Transaction #{ transaction}"
                                  end
                                end
                              end
                            </code>
                          </pre>

        <aside class="notes">
          <ul>
            <li>
              Agent makes it really easy to maintain and update state of blockchian
            </li>
            <li>given the blockchain is an irreversible leger, we will only want to add blocks to the chain</li>
            <li>Having an agent store the state makes this really easy</li>
          </ul>
        </aside>

      </section>

      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
              defmodule Gossip.BlockChain do
                ...
                def update_and_retrieve_chain(block) do
                  case Agent.update(@me, fn(block_chain)
                   -> %{block_chain | blocks: [block | block_chain.blocks] } end ) do
                    .....
                  end
                end
                ...
              end
            </code>
          </pre>

        <aside class="notes">
          <ul>
            <li>
              Agent makes it really easy to maintain and update state of blockchian
            </li>
            <li>given the blockchain is an irreversible leger, we will only want to add blocks to the chain</li>
            <li>Having an agent store the state makes this really easy</li>
          </ul>
        </aside>

      </section>

      <section class="center">
        <div>So how do we actually communicate
          <br /> between other nodes? </div>
        <aside class="notes">
          we need some client-server behavior to allowe nodes to make requests and receive messages from each other.
        </aside>
      </section>


      <section class="center">
        <h3>Introducing GenServer</h3>
        <aside class="notes">
          <ul>
            <li>
              OTP provides us a behaviour module for implementing the server of a client-server relation.
              <li>
                <li>
                  GenServer stands for generic server
                </li>
                <li>It does this by providing a set of generic callbacks that can be implemented</li>
                <li>developers are only required to impement the ones they need</li>
                <li>Genserers also allow us to maintian state</li>
          </ul>
        </aside>
      </section>


      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                                      defmodule Gossip.Server do
                                        use GenServer

                                        def start_link(_) do
                                          GenServer.start_link(__MODULE__, nil, name: __MODULE__)
                                        end

                                        def init(_) do
                                          {:ok, %{id: self(), block_chain: []}, uuids: []}}
                                        end
                                        ......
                                      end
                                  </code>
                                </pre>
      </section>


       <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                                      defmodule Gossip.Server do
                                        use GenServer

                                        ......

                                        def send_message() do
                                          GenServer.cast( __MODULE__ , {:mine_and_gossip})
                                        end

                                        def handle_cast({:mine_and_gossip}, my_state) do
                                          ....
                                          blocks = BlockChain.add_block(transaction)
                                          ....
                                          new_block_chain = me
                                          |> Map.put(:block_chain, block_chain, locks)
                                          |> Map.put(:uuid, UUID.uuid4())


                                          send_block_chain(new_block_chain, Node.list)
                                          my_state = %{my_state | me: new_block_chain }
                                          {:noreply, my_state}
                                        end
                                      end
                                  </code>
                                </pre>

        <aside class="notes">
          <ul>
            <li>we want ot send messages to our peers</li>
            <li>and we just need to send and do not need to wait for a response</li>
            <li>so we can send asynchronously</li>
            <li>Genserver behaviour makes it really easy</li>
            <li>Genserver.cast allows us to make an asynchronous call - we specify the module and teh arugments to pattern match
              against</li>
            <li>Genserver handle_cast is invoked ot handle asynchornous cast messages</li>
            <li>it always returns :noreply and the state of the GenServer</li>
          </ul>
        </aside>
      </section>

      <section class="center">
        <div>So we just updated our current state of the block chain </div>
      </section>

      <section class="center">
        <div>How see our current state</div>
      </section>

      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                                  defmodule Gossip.Server do
                                    use GenServer

                                    ......
                                    def retrieve_state() do
                                      GenServer.call( __MODULE__, {:retrieve_state} )
                                    end

                                    def handle_call({:retrieve_state}, from, my_state) do
                                       {:reply, my_state, my_state}
                                    end
                                  end

                                </code>
                              </pre>

        <aside class="notes">
          <ul>
            <li>dealt with asynchronous transactions</li>
            <li>in this case can also deal with synchronous transactions</li>
          </ul>
        </aside>
      </section>

      <section class="center">
        <div>So we just added a block and sent it to our peers, but how are the nodes able to receive it?</div>
      </section>


      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                                      defmodule Gossip.Server do
                                        use GenServer

                                        ......
                                        def send_block_chain(new_block_chain, peers) do
                                          Enum.map(peers, fn (peer) ->
                                            Node.connect(peer)
                                            GenServer.cast({__MODULE__, peer}, {:message_from_peer, new_block_chain})
                                          end)
                                        end

                                        def handle_cast({:message_from_peer, block_chain_message = %{block_chain: blocks},  id: id, uuid: uuid }}, my_state) do
                                        ...
                                            if !Enum.member?(my_state.uuids, block_chain_message.uuid) do
                                              case BlockChain.validate_blocks(blocks)  &amp;&amp; length(blocks) > length(me.block_chain)do
                                                {:ok, true} ->
                                                  updated_blocks = BlockChain.swap_chain(blocks)
                                                  .....
                                                  send_block_chain(updated_blocks, Node.list)
                                                  {:noreply, my_state}
                                              ...
                                            end
                                          end
                                        end
                                      end

                                  </code>
                                </pre>


        <aside class="notes">
          <ul>
            so again gen server provides us a really nice interface for sending and receiving messages, that makes this message passing
            easy
          </ul>
          <ul>one important thing to note here </ul>
          <ul>one of the block chain works by a concencus algorithm</ul>
        </aside>
      </section>


      <!-- <section class="center">
                                    <h3></h3>Fork Choice rule

                                    <h2>Message passing</h2>
                                    <img src="lib/images/process_message_passing.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
                                     <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: http://benjamintan.io/blog/2013/06/25/elixir-for-the-lazy-impatient-and-busy-part-2-processes-101/</div>
                                     <aside class="notes">
                                       <ul>
                                         <li>
                                           the consensus algorithm that Satoshi invented was called the fork choice rule
                                         </li>
                                         <li>
                                           you are a node mining a blokc chain, once you hear of a node on height h, you reject all blockcahins less than ehight h, adn start mining on that chain
                                         </li>
                                         <li>I will also respect teh first chain I hear about</li>
                                         <li>
                                           this makes it very hard to douvle spend
                                         </li>
                                         <li>so when our nodes are minnig blocks, if they receive a chian that is longer than their's they will switch to minnig the longer chain</li>
                                       </ul>
                                     </aside>

                                  </section> -->


                                  <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
                                    <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                                                <code data-trim style="max-height: none">
                                            defmodule Gossip.Server do
                                              use GenServer

                                              def init(_) do
                                                  schedule_send_message()
                                                  {:ok, %{ me: %{id: self(), block_chain: []}, uuids: []}}
                                                end
                                              end

                                              def handle_info(:schedule_send_message, state) do
                                                send_message()
                                                schedule_send_message()
                                                {:noreply, state}
                                              end



                                              defp schedule_send_message do
                                                Process.send_after(self(), :schedule_send_message, 30000) # In 30 seconds
                                              end
                                            end

                                        </code>

                                    </pre>
        <aside class="notes">
          <ul> handle info callback is used to handle all other messages. Allowing us to implement this times interval behavior</ul>
        </aside>
      </section>



      <section class="center">
        To keep an eye on this process we use another supervisor
      </section>

      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                                              defmodule Gossip.Application do
                                                use Application
                                                use Supervisor

                                                def start(_type, _args) do
                                                  Supervisor.start_link([{Gossip.Server, []}, {Gossip.BlockChain, []}],
                                                  strategy: :one_for_one, name: Gossip.Supervisor)
                                                end
                                              end

                                            </code>
                                          </pre>
      </section>


      <section class="center">
        <h3>Distributed Elixir</h3>

        <aside class="notes">
          so we talk about a distrbuted netwrok, but how do we actually communicate
        </aside>
      </section>


      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                                                  iex --sname anna1@annasmbk
                                                  --------------------------------

                                                  iex --sname anna2@annasmbk
                                                  ------------------------------------

                                                  iex --sname anna3@annasmbk

                                              </code>
                                            </pre>

        <aside class="notes">
          <ul>Node.connect allows you to create a connectiosn to a peer node by passing in teh peer address</ul>
          <ul>if you connect node 1 to 2, adn 3, 2 nad 3 will know about each other</ul>
          <ul>there is a way to turn this off if it si not desired</ul>
          <ul>just as easy to connect on disributed machines. Erlang Uses TCP/IP protocol</ul>
        </aside>
      </section>

       <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                                                  def connect_to_peers(peers) do
                                                    Enum.map(peers, fn (peer) -> Node.connect(peer) end)
                                                  end

                                              </code>
                                            </pre>

      </section>



      <section class="center" data-background-color="#fffff" style="top: 0px; padding: 0px 0px">
        <pre class="elixir" style="font-size: .55em; margin: 0 0; width: 100%; padding: 0">
                    <code data-trim style="max-height: none">
                                              iex --name anna1@ip --cookie pb -S mix
                                            </code>

                                          </pre>
        <aside class="notes">
          <ul>
            <li>
              connecting with this name with my ip provides an adress for other nodes not on my machine to connect
            </li>
            <li>
              address in name at host.name - on your machine you can use snmaes which don't require an ip, but acorss machins a full name
              is necessary
            </li>
            <li>
              the cookies are authenitcation built in at the lowers levels - when nodes connect they compare the cookie, if they don't
              match the connection is afalse
            </li>
          </ul>
        </aside>
      </section>


      <section class="center">
        <h3>Let's try it!</h3>
      </section>


      <section class="center" data-background-color="#025A6E">
        <h2>Thank you!</h2>
        <p style="font-size: 30px">Anna Neyzberg • @ANeyzb • anna@carbonfive.com</p>
      </section>






























































      <!--

































              <aside class="notes">
                  <ul>
                      <li>When we think about how to build concurrent applications, and how to deal with monitorin, and timeouts etc, adn servers, there are things to think about.</li>
                      <li>OTP framework takes care of this by grouping these essential practices into a set of libraries that have been carefully engineered and battle-hardened over years.</li>
                      <li>The OTP framework is also a set of modules and standards designed to help you build applications. </li>
                  <ul>
              </aside>
          </section>
        <section>
          <h3>Distributed Networks</h3>h3>

          <aside class="notes">
              <div>Open Telecom Platform</div>

            </aside>
        </section>



          <section class="center" data-background-color="#025A6E">
            <div>Thank you!</div>
            <p style="font-size: 30px">@ANeyzb • anna@carbonfive.com • elixirbridge.org • @elixirbridge </p>
          </section> -->
      </div>
      </div>

      <script src="lib/js/head.min.js"></script>
      <script src="js/reveal.js"></script>

      <script>
        // More info about config & dependencies:
        // - https://github.com/hakimel/reveal.js#configuration
        // - https://github.com/hakimel/reveal.js#dependencies
        Reveal.initialize({
          dependencies: [
            // {src: 'node_modules/highlightjs/highlight.pack.js'},
            // {
            //   src: 'node_modules/reveal-code-focus/reveal-code-focus.js',
            //   async: true,
            //   callback: function() {
            //     RevealCodeFocus();
            //   }
            // },
            { src: 'plugin/markdown/marked.js' },
            { src: 'plugin/markdown/markdown.js' },
            { src: 'plugin/notes/notes.js', async: true },
            { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
          ]
        });
      </script>
</body>

</html>
