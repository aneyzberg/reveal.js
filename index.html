<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>reveal.js</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/white.css">

  <!-- Theme used for syntax highlighting of code -->
  <!-- <link rel="stylesheet" href="lib/css/zenburn.css"> -->

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section class="center" data-background-color="#025A6E">
        <h2>Crypto + Concurrency</h2>
        <p style="font-size: 30px">Anna Neyzberg • @ANeyzb • anna@carbonfive.com</p>
      </section>

      <section>
        <h3>About me:</h6>
          <ul>
            <li>I co-founded ElixrBridge founders</li>
          </ul>

          <img src="lib/images/rockclimbing.jpg" width="400px" />
      </section>

      <section class="center">
        <h3>What I want to talk about today?</h3>

        <ul>What is Bitcoin/Blockcahin</ul>
        <ul>How does it work?</ul>
        <ul>Why try and build it in elixir</ul>
      </section>


    <section>
        What is Bitcoin?
      </section>

      <section>
          <h1>Bitcoin uses blockchain to implement decentralized leger for payemnts</h1>
      </section>

      <section>
        <h1>It is a secure semi-annonymous store of value</h1>
      </section>

      <section>
        <h1>what is value</h1>
      </section>

      <section>
        Take a step back and look ook at value in the context of money
      </section>


      <!-- <section>
          <h3>What is money?</h3>

            <aside class="notes">
                <ul>
                  <li>unit of account (we can denominate value)</li>
                  <li>medium of exchange</li>
                  <li>store of value</li>
                  <li>cash - intrinsically valuable good that allows you to pay for material goods</li>
                  <li>credit - allows you to determine debt</li>
                </ul>
            </aside>
        </section> -->

        <section>
            "Money is any clearly identifiable object of value that is generally accepted as payment for goods and services and repayment of debts within a market,
             or which is legal tender within a country. "
           <div class="credit" style="padding-right: 22px">credit: https://en.wikipedia.org/wiki/History_of_money</div>
           <aside class="notes">
             <ul>
               <li>source of value you can use to get other things of value</li>
             </ul>
           </aside>
        </section>

      <section>
          <h3>History of money</h3>
          <img src="lib/images/history_of_money.jpg" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
          <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://steemit.com/steemit/@cryptomoni/6-stages-of-history-and-evolution-of-money</div>
          <aside class="notes">
              <ul>
                <li>1000 a.d. Song Dynasty - first bank note</li>
                <li>1944 Bretton woods agreement  -  international monetary and financial order - every currency required to fix to gold</li>
                <li> 1958 visa</li>
                <li></li>
                <li>scarce(mined infrequently)</li>
                <li>durable(hard to break)</li>
                <li>hard to fake</li>
                <li>arbitrarily divisible</li>
              </ul>
          </aside>
      </section>


      <section>
          <h1> 1971 - Nixon breaks from bretton woods and cancels convertiblilyt of us dollars to gold./h1>
        <aside class="notes">
          <ul>
            <li>metals valuable, scarce, durable, hard to fake, and arbitraily divisible</li>
            <li>gollar has value because you can pay taxes</li>
            <li>people are willing to use it, believe u.s economy is going to keep working</li>
            <li>fiat's value is not about instrinsic value, but about making a guess about the future</li>
          </ul>
        </aside>
      </section>

      <section>how can you create non-collateralized cash that is still valuable
        <aside class="notes">
          <ul>
              "create something scarce"
              "disincentive to buy into a system that grows in supply"
              "also people need to be using it"
              "paying taxes"
          </ul>
        </aside>
      </section>


      <section>
        So back to Bitcoin
      </section>



      <section>Big idea behind cryptocurrencies...</section>

      <section>Do value transfer over the internet</section>


      <section>
          <ul>
              first time we have a stoer of value that is comletely digital
            </ul>
            <ul>
              people are willing to use and can excahnge for goods and servces
            </ul>
            <ul>it is scarce</ul>

      <section>
        Digital Transfer of value that is anonymous and secure
      </section>


      <section>
          <h1>Cryptography</h1>
          <aside class="notes">
            <ul>
              <li>mostly government or military</li>
              <li>before 1970 cryptography mostly govt or military</li>
              <li>military emission till 199</li>
              <li>foretathers of cryptography belived in using cryptography use cryptography to break monopoly of the state</li>
              <li>advent of computers changed things</li>
          </aside>
      </section>


      <section>
          <img src="lib/images/cypher_punks.jpeg" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
          <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://medium.com/swlh/cypherpunks-and-the-rise-of-cryptocurrencies-899011538907</div>
          <aside class="notes">
            <ul>
               <li>1992 Cyper Punks Eric Hughes, Timothy C. May and John Gilmore started an organization humorously called cyperhpunks</li>
                 mailing list started </li>
              <li>1994 700 subscribers</li>
              <li>1995 Eric Hughes wrote the cypherpunks manifesto
                  online privacy communications
                  - respecting rights of peopel to use pseudonyms and maintain anonymity in online world
                  - up to citizens to check govt pwer
                  - your powere in anonymity and resistance to censorship
                  - hiding the act of hiding- by hiding you should not be incriminating yourself
                  - TNO
              </li>
              <li> PGP and Tor cyperpunk projects</li>
              <li> 2008 crisis central govt has too much power - hyperinflation happens becuase govt prints money</li>
              <li>several early cypherpunk experimented with digital currencies that were not successful, but that Satoshi drew inproation from</li>
            </ul>
        </aside>
      </section>

      <section>
          <h3>"Privacy is necessary for an open society in the electronic age. ...
              We cannot expect governments, corporations, or other large, faceless organizations to grant us privacy ...
               We must defend our own privacy if we expect to have any. ... Cypherpunks write code. We know that someone has to write software to defend privacy, and ...
               we're going to write it.""</h3>
            <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: Eric Hughes "A Cypherpunk's Manifesto"</div>
      </section>

      <section>
          PGP &amp; Tour
          <img src="lib/images/pgp.gif" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
          <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://www.askbjoernhansen.com/2004/12/15/foolish_verifie.html/div>


          <aside class="notes">
            <ul>
              <li>
                famous cyperpunk projects
              </li>
            </ul>
          </aside>
        </section>


      <section>
        Many Early attempts at digitial currencies failed
        <aside class="notes">
          <ul>
            <li>
              satoshi took inspiration from them
            </li>
          </ul>
        </aside>
      </section>

      <section>
        2008 Financial Crisis happened
        <aside class="notes">
          <ul>
            <li>
              talk in the cypherpunk community about the need for an alternative to storing value within the government
            </li>
          </ul>
        </aside>
      </section>

      <section>
         Bitcoin Goes live in 2009
      </section>

      <section>
          “With e-currency based on cryptographic proof, without the need to trust a third party middleman, money can be secure and transactions effortless.” — Satoshi Nakamoto

        <aside class="notes">
            <ul>
              <li>allows store value outside of governments</li>
              <li>decentarlized</li>
              <li>no single point of failure</li>
              <li>anonymity</li>
              <li>Big idea behind cryptocurrencies, - do value transfesr over teh internet</li>
            </ul>
        </aside>
      </section>

      <section>
        <h3>What is BlockChain?</h3>
            <img src="lib/images/block_chain.jpeg" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
            <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://hackernoon.com/ecommerce-on-the-blockchain-part-two-895e006b1bb3</div>
            <aside class="notes">
                <ul>
                  <li>allows store value outside of governments</li>
                  <li>decentarlized</li>
                  <li>decentralized</li>
                  <li>no single point of failure</li>
                  <li>anonymity</li>
                </ul>
            </aside>
      </section>

      <section>
          <img src="lib/images/block_chain_explanation.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
          <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://computersecuritypgp.blogspot.com/2016/05/what-is-blockchain.html</div>

          <aside class="notes">
              <ul>
                <li>A blockchain is a distributed database that maintains a continuously growing list of data records that cannot be tampered.</li>
                <li>A blockchain consists of a number of blocks that are linked with each other with each block linked with its previous block.</li>
                <li>and, each block consists of a batch of timestamped transactions and a hash of previous block. As the blocks are linked with each other forming a chain,
                  hence the name of the database.</li>
                <li>anonymity</li>
                <li>it is very difficult to corrup the leger</li>
              </ul>
          </aside>
      </section>

      <section>
        <h1>So how Does Bitcoin use the Blockchain</h1>
      </section>


      <section>
          <img src="lib/images/blockchain_network.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
          <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://blockgeeks.com/guides/what-is-blockchain-technology/</div>

          <aside class="notes">
              <ul>
                <li>decentralized</li>
                <li>each node has a copy of the entire blockchain</li>
                <li>when a transaction is sent from one node to another - </li>
                <li>tenets we talked about earlier - decentralized </li>
              <li>when two people want to exchage bitcoin, and encrypted record of transaction is sent to all other nodes in the network</li>
              <li>nodes are able to verify the transaction - when enough nodes agree on authenticity of transaction it is added to the leger</li>
              <li>anonymity</li>
              </ul>
          </aside>
        </section>


      <section>
          <h2>Proof of Work</h2>


          <aside class="notes">
            <ul>
                <li>Blocks get added through the chain by mining</li>
                <li>proof of work</li>
                <li>In bitcoin the service string is encoded in the block header data structure, and includes a version field,
                  the hash of the previous block, the root hash of the merkle tree of all transactions in the block, the current time, and the difficulty.</li>
                  <li>Version (4 bytes)
                      Hash of the previous block, thus making a chain of block (32 bytes)
                      Merkle root, the tree of transactions' reference (32 bytes)
                      Timestamp, number of seconds since 1970-01-01 00:00 (4 bytes)
                      Bits, a representation of the networks current difficulty (4 bytes)
                      Nonce, incremented when mining (4 bytes)</li>
                <li>so when miners mine a block - they use the blockheader and a nonce - and a nonce (randomg value) that is hashed to try and find proof of work</li>
                <li>A blockchain consists of a number of blocks that are linked with each other with each block linked with its previous block.</li>
                <li>and, each block consists of a batch of timestamped transactions and a hash of previous block. As the blocks are linked with each other forming a chain,
                  hence the name of the database.</li>
                  <li>once found block, it communicates to network. If block is valid other nodes add it, and</li>
                  <li>incentivizes nodes to be good actors</li>
                <li>incentives people to contribute</li>
                <li>The mechanism behind proof of work was a breakthrough in the space
                  because it simultaneously solved two problems.
                  First, it provided a simple and moderately effective consensus algorithm, allowing nodes in the network to collectively agree
                  on a set of canonical updates to the state of the Bitcoin ledger. Second, it provided a mechanism for allowing free entry into the consensus process,
                  solving the political problem of deciding who gets to influence the consensus, while simultaneously preventing sybil attacks.</li>
                <li> It does this by substituting a formal barrier to participation, such as the requirement to be registered as a unique entity on a particular list,
                  with an economic barrier - the weight of a single node in the consensus voting process is directly proportional to the computing power that the node brings.</li>
            </ul>
            </aside>
        </aside>

        <section>
            <h1>How does the block chain grow?</h1>


          <aside class="notes">
            <ul>
              <li>Consensus algorithm that Sathoshi invented is called the Fork Choice Rule (Nakomoto consensus)</li>
              <li>Listen to first blockcahin at height h I hear about</li>
              <li> most likely majority of nodes agree on what longest block is</li>
            </ul>
          </aside>
        </section>



        <section>
         <h1>Gossip Protocol</h1>
          <p>"A gossip protocol[1] is a procedure or process of computer-computer communication that is based on the way social networks disseminate information or how epidemics spread.</p>
            <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: https://blockgeeks.com/guides/what-is-blockchain-technology/</div>

            <aside class="notes">
                <ul>
                    <li>part of the Bitcoin experiment is the underlying blockchain technology as a tool of distributed consensus</li>
                </ul>
              </aside>
        </section>

        <section>
            So why think about this in the context of Elixir?
          <aside class="notes">
            <ul>
                <li>bitcoin uses blockchain to implement decentralized leger for payemnst</li>
                <li>nodes send messages to the netwrok using a gossip protocol</li>
                <li>to crete new blocks you have to do some work </li>
                <li>so we need a distributed system that is concurrent, that communicates via message passing, sound familiar</li>
                <li>so given this I tried to build a crypotcurrency in eliixr. Before I talk to you about what that experience was like, I want to review teh properties of elixir that make it such good fit</li>
            </ul>

          </aside>
         </section>

         <section>
           Network of distributed nodes that each have a copy of the block chain and communicate via message passing
         </section>

         <section>
           So how do we build that?
         </section>

         <section>
           Let's take a quick look at how messge passing works in elixir
         </section>



         <section>
            <h2>Processes</h2>
            <aside class="notes">
              <ul>
                  <li>how does work get down in elixir</li>
                  <li>all code in elixr runs inside of processes</li>
                  <li>processes are isolated from each other, run concurrent to one another,
                     and communicate via message passing. </li>
                  <li>small programs communciate to each other via message passing, supe rlight weight</li>
                  <li>they seem like native threads but are simpler, and can have thousands of processes running concurrently</li>
                  <li>thanks to the erlang VM, our processes are working across all your CPU's so you are maximizng efficiency.</li>
              </ul>

             </aside>
          </section>


          <section>
              ```elixir
                defmodule Example do
                  def subtract(a, b) do

                  end
                end


                iex> Example.subtract(3, 2)
                1
                :ok
              ```
          </section>

          <section>
              ```elixir
                spawn(Example, :subtract, [3, 2])
                1
                #PID<0.80.0>
              ```

              <aside class="notes">
                <ul>
                  <li>easiest way to create a process is to call spawn</li>
                  <li>spawn takes an anonymous or named function</li>
                  <li>spawn returns a process Identifier or PID</li>
                </ul>

              </aside>

            </section>

         <section>
           <h2>Message passing</h2>
           <img src="lib/images/process_message_passing.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
            <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: http://benjamintan.io/blog/2013/06/25/elixir-for-the-lazy-impatient-and-busy-part-2-processes-101/</div>


           <aside class="notes">
             <ul>
              <li>processes communicate by passing messages</li>
              <li>here are two main components to this: send/2 and receive</li>
              <li> send function allows us to send to PIDs and receive function allows us to match messsges</li>
            </ul>
            </aside>
         </section>

         <section>
           ```elixir
            defmodule Greet do
              def by_name do
                receive do
                  {:name, name} -> IO.puts("Hello #{name}")
                end

                by_name
              end
            end

            iex> pid = spawn(Greet, :by_name, [])
            #PID<0.108.0>

            iex> send pid, {:name, "Ben"}
            "Hello Ben"
            {:name, "Ben"}

            iex> send pid, :ok
            :ok
          ```

          <aside class="notes">
              <ul>
               <li>create a process</li>
               <li>pass in our arguemtne which is a tuple of name and teh string "bem</li>
               <li>if matches it recieve expected string "hello ben"</li>
             </ul>
          </aside>
        </section>


        <section>
          <h1>Process Linking &amp; Process Montioring<h1>

           ```elixir
              defmodule Connection do
              def explode, do: exit(:kaboom)
              end

            iex> spawn(Example, :explode, [])
            #PID<0.66.0>

            iex> spawn_link(Example, :explode, [])
            ** (EXIT from #PID<0.57.0>) evaluator process exited with reason: :kaboom
          ```
            <aside class="notes">
                <ul>
                  <li>other things that we can do with processes</li>
                  <li>problen with spawn is we don't know if our process crashes</li>
                  <li>this allows our processes to recieve exit notifications from each other</li>
                  <li>now we don't want to our current process to die, we can trap the exit messages and handle them so current process does not die </li>
                </ul>
            </aside>

          </section>


          <section >
            <h1>Agents</h1>
            ```elixir
            `iex> {:ok, agent} = Agent.start_link(fn -> [1, 2, 3] end)
              {:ok, #PID<0.65.0>}

              iex> Agent.update(agent, fn (state) -> state ++ [4, 5] end)
              :ok

              iex> Agent.get(agent, &(&1))
              [1, 2, 3, 4, 5]
            ```

            <aside class="notes">
                <ul>
                  <li>Agents are an abstraction around background processes maintaining state.
                    We can access them from other processes within our application and node. The state of our Agent is set to our function’s return value:
                  </li>
                </ul>
            </aside>
          </section>


          <section>
            <h2>Tasks</h2>
            ```elixir
              defmodule Example do
                def double(x) do
                  :timer.sleep(2000)
                  x * 2
                end
              end

              iex> task = Task.async(Example, :double, [2000])
              %Task{pid: #PID<0.111.0>, ref: #Reference<0.0.8.200>}

              #  Do some work

            iex> Task.await(task)
            4000
            ```

            <aside class="notes">
                <ul>
                  <li>Tasks provide a way to execute a function in the background and retrieve its return value later.
                    They can be particularly useful when handling expensive operations without blocking the application execution.
                  </li>
                </ul>
            </aside>
          </section>

          <section>
            Back to BlockChain

            <aside class="notes">
                <ul>
                  <li>so we saw some abstractions for concurrency around message passing and storing state</li>
                  <li>w can run mutiple processes at teh same time, we can store state in processes and communicate asynchronously via messages</li>
                  <li>no we'll take a look at how elixir and especially Erlan allows us to create </li>
                  <li>yet to build a blockshain network, we want greater conrtol of the concurrency and message passing</li>
                  <li> We want something to manage that more complicated behavrio</li>
                </ul>
            </aside>
          </section>

          <section>
            <h1>OTP</h1>


            <aside class="notes">
                <ul>
                    <li>When we think about how to build concurrent applications, and how to deal with monitorin, and timeouts etc, adn servers, there are things to think about.</li>
                    <li>OTP framework takes care of this by grouping these essential practices into a set of libraries that have been carefully engineered and battle-hardened over years.</li>
                    <li>The OTP framework is also a set of modules and standards designed to help you build applications. </li>
                <ul>
            </aside>
          </section>


          <section>
            <h1>So Let's start buildig</h1>
          </section>

          <section>
            We know we need to somehow build a chain of blocks
          </section>

          <section>
            So let's start with a single block
          </section>


          <section>

            ```elixir
              defmodule Block do

                defstruct nonce: nil, previous_hash: nil, transaction: nil

                def create({:initial, work_factor}, transaction) do
                  ,,,
                end

                def create({:previous_hash, previous_hash, work_factor}, transaction) do
                  hash_info = mint(previous_hash, work_factor)
                  %Block{nonce: hash_info.nonce, previous_hash: previous_hash, transaction: transaction}
                end

                def mint(previous_hash, work_factor) do
                  nonce = 0
                  .....
                  create_hash(previous_hash, nonce, matcher)
                end

                def create_hash(previous_hash, nonce, matcher) do
                  stringified_nonce = Integer.to_string(nonce)
                  hash =  :crypto.hash(:sha256, [previous_hash, stringified_nonce])
                  |> Base.encode16
                  |> String.downcase

                  match? = matcher
                  |> matches?(hash)

                  case match? do
                      false ->
                        nonce = nonce + 1
                        create_hash(previous_hash, nonce, matcher)
                      true ->
                        %{nonce: nonce, previous_hash: previous_hash, hash: hash}
                  end
                end
                ....
              end

            ```


            <aside class="notes">
              <ul>
                <li>essentially we have a module, that creates and manipulate a Struct that has a nonce, the hash generated by the previous block, and a trnsaction</li>
                <li>we receive a transaction, and create a block based on the workfactor</li>
                <li>work in progress - given that the determing the work factor takes time, i haven't done it year, but you might think that you could easily leverage -
                  how easily processes can run concurrently, to have that hashing potentially happen at the same time by multiple processses to make hashing more efficient</li>
              </ul>
            </aside>
          </section>


          <section>
            Ok, we have a block....How to we create a chain
          </section>


          <section>
            ```elixir
              defmodule Gossip.BlockChain do

              @work_factor 1
              @me __MODULE__
              @block_reward 100

              defstruct blocks: [], pub_key: nil, priv_key: nil

              def start_link() do
                {:ok, pid} = Agent.start_link(&amp;initial_state/0, name: @me)
              end

              def child_spec(_opts) do
                %{
                  id: __MODULE__,
                  start: {__MODULE__, :start_link, []},
                  type: :worker,
                  restart: :permanent,
                  shutdown: 500
                }
              end


              def initial_state do
                {priv_key, pub_key} = RSA.generate_rsa
                %BlockChain{blocks: [], priv_key: priv_key, pub_key: pub_key}
              end
            end

          ```

          <aside class="notes">
            <ul>
              <li>So we need each node to have a chain of blocks</li>
              <li>so as you can see we have another struct</li>
              <li>now remeber that message identification is all done via cryptography, so each node needs a public nad private key</li>
              <li>it iwll only send its pub key, not a security expert or cryptographer</li>
              <li>but there are a couple of other intersting things happend in thsi file</li>
              <li>so where are we storing the state. notice that to start that we have a start link function, that is starting an agen</li>
              <li>remember agenst can stor state</li>
              <li>So this module is storing our Block Chain struct as state in our agent process. and we can retreive manipulte and update that state</li>
            </ul>
          </aside>
          </section>

          <section>

              ```elixir
              defmodule BlockChain do
                @work_factor 1
                @me __MODULE__
                @block_reward 100

                defstruct blocks: [], pub_key: nil, priv_key: nil

                def start_link() do
                  {:ok, pid} = Agent.start_link(&amp;initial_state/0, name: @me)
                end

                def child_spec(_opts) do
                  %{
                    id: __MODULE__,
                    start: {__MODULE__, :start_link, []},
                    type: :worker,
                    restart: :permanent,
                    shutdown: 500
                  }
                end
              end
            ```
            <aside class="notes">
                <ul>
                  <li>So we have this background process maintaing our blockchain</li>
                  <li>yet how do we know if its up, and what happends if it goes down</li>
                  <li>So this is where we go back to some of the Powerful features of OTP</li>
                </ul>
            </aside>
          </section>


          <section>
            <h1>Supervisors</h1>


            <aside class="notes">
                <ul>
                  <li>Supervisors are specialized processes with one purpose: monitoring other processes. </li>
                  <li>These supervisors enable us to create fault-tolerant applications by automatically restarting child processes when they fail.</li>
                </ul>
            </aside>
          </section>

          <section>
            How do we set this up?
          </section>

          <section>
            ```elixir
              defmodule Application do
                use Application
                use Supervisor

                def start(_type, _args) do
                  Supervisor.start_link([{Gossip.BlockChain, []}], strategy: :one_for_one, name: BlockChain.Supervisor)
                end
              end
            ```


            <aside class="notes">
                <ul>
                  <li>so in our main application module, we using the supervisor behavior </li>
                  <li>the magic happens in our start link function.</li>
                  <li>here the supervisor takes a lit of child processes it is supervising, each argument to the list is a tuple with name of child process, adn initial arguments
                    to be passed to that process, and a strategy for restarting.
                  </li>
                  <li>there are many strategies for restarting. in this case, we are saying only restart the failed process.</li>
                  <li>So superviosr will call start_link to start its respective child processes</li>
                </ul>
            </aside>
          </section>


          <section>
            <h2>child spec</h2>
            ```elixir
              defmodule BlockChain do
                @work_factor 1
                @me __MODULE__
                @block_reward 100

                defstruct blocks: [], pub_key: nil, priv_key: nil

                def start_link() do
                  {:ok, pid} = Agent.start_link(&amp;initial_state/0, name: @me)
                end

                def child_spec(_opts) do
                  %{
                    id: __MODULE__,
                    start: {__MODULE__, :start_link, []},
                    type: :worker,
                    restart: :permanent,
                    shutdown: 500
                  }
                end
              end
            ```
            <aside class="notes">
                <ul>
                  <li>Now back in our  BlockChain module notice two things</li>
                  <li>we also have a function called child_spec. This tells the supervisor how to start the blockchain module </li>
                  <li>so when it called start link, it will call start which defaults to start_link</li>
                  <li>we also tell it how to restart the process - in this case permenent - always restart</li>
                </ul>
            </aside>
          </section>


          <section>
            Supervisors makes fault tolerance easy
          </section>

          <section>
            And fault tolerance is what we want in a distributed blockchain system
          </section>


          <section>Let's look at our blockchain module again</seection>

          <section>
            ```elixir
              defmodule Gossip.BlockChain do

                @work_factor 1
                @me __MODULE__
                @block_reward 100

                ....
                def add_block(transaction) do
                  add_new_block(transaction)
                end

                ...

                def update_and_retrieve_chain(block) do
                  case Agent.update(@me, fn(block_chain) -> %{block_chain | blocks: [block | block_chain.blocks] } end ) do
                    :ok ->
                        get_state
                    _ -> IO.puts "did not update"
                  end
                end

                def add_new_block(transaction) do
                ..
                  case Transaction.valid?(pub_key, transaction) do
                      {:ok, true} ->
                        # create new block
                        update_and_retrieve_chain(block)
                      _ ->
                        IO.puts "Invalid Transaction #{ transaction}"
                  end
                end
             end
            ```

            <aside class="notes">
              <ul>
                <li>
                  Agent makes it really easy to maintain and update state of blockchian
                </li>
                <li>given the blockchain is an irreversible leger, we will only want to add blocks to the chain</li>
                <li>Having an agent store the state makes this really easy</li>
              </ul>
            </aside>

          </section>


          <section>
            <h1>Transactions</h1>
          </section>

          <section>
            A quick note about transactions
          </section>

          <section>
            ```elixir
              defmodule Gossip.Transaction do
                alias Gossip.Transaction
                alias Gossip.RSA


                defstruct to: '', from: '', amount: 0, signature: ''

                def new_transaction(to, from, amount, private_key) do
                  %Transaction{
                    to: to,
                    from: from,
                    amount: amount,
                    signature: sign(private_key, {to, from, amount})
                    }
                end

                def sign(priv_key, {to, from, amount}) do
                  hash = :crypto.hash(:sha256, [to,  amount])
                  {:ok, signature} = ExPublicKey.sign(hash, priv_key)
                  signature
                end

                def valid?(pub_key, %Transaction{to: to, from: from, amount: amount, signature: signature}) do
                  message = :crypto.hash(:sha256, [to, amount])
                  {:ok, valid}  = ExPublicKey.verify(message, signature, from)
                end
              end
            ```

            <aside class="notes">
              <ul>
                <li>explain transactions in blockchian</li>
              </ul>
            </aside>
          </section>

          <section>
              So how do we actually communicate between other nodes?
            <aside class="notes">
              we need some client-server behavior to allowe nodes to make requests and receive messages from each other.
            </aside>
          </section>

          <section>
            Introducing GenServer
            <aside class="notes">
              <ul>
                <li>
                  OTP provides us a behaviour module for implementing the server of a client-server relation.
                <li>
                <li>
                  GenServer stands for generic server
                </li>
                <li>It does this by providing a set of generic callbacks that can be implemented</li>
                <li>developers are only required to impement the ones they need</li>
                <li>Genserers also allow us to maintian state</li>
              </ul>
            </aside>
          </section>



          <section>
            ```
              defmodule Gossip.Server do
                use GenServer

                def start_link(_) do
                  GenServer.start_link(__MODULE__, nil, name: __MODULE__)
                end

                def init(_) do
                  {:ok, %{id: self(), block_chain: []}, uuids: []}}
                end

                ......
              end
            ```
          </section>


          <section>

              ```
              defmodule Gossip.Server do
                use GenServer

                ......

                def send_message() do
                  GenServer.cast( __MODULE__ , {:mine_and_gossip})
                end

                def handle_cast({:mine_and_gossip}, my_state) do
                  ....
                  blocks = BlockChain.add_block(transaction)
                  ....
                  new_block_chain = me
                  |> Map.put(:block_chain, block_chain, locks)
                  |> Map.put(:uuid, UUID.uuid4())


                  send_block_chain(new_block_chain, Node.list)
                  my_state = %{my_state | me: new_block_chain }
                  {:noreply, my_state}
                end
              end
            ```

            <aside class="notes">
              <ul>
                <li>we want ot send messages to our peers</li>
                <li>and we just need to send and do not need to wait for a response</li>
                <li>so we can send asynchronously</li>
                <li>Genserver behaviour makes it really easy</li>
                <li>Genserver.cast allows us to make an asynchronous call - we specify the module and teh arugments to pattern match against</li>
                <li>Genserver handle_cast is invoked ot handle asynchornous cast messages</li>
                <li>it always returns :noreply and the state of the GenServer</li>
              </ul>
            </aside>
          </section>

          <section>
            So we just updated our current state of the block chain
          </section>

            <section>
              How see our current state
            </section>

            <section>
              ```elixir
                defmodule Gossip.Server do
                  use GenServer

                  ......
                  def retrieve_state() do
                    GenServer.call( __MODULE__, {:retrieve_state} )
                  end

                  def handle_call({:retrieve_state}, from, my_state) do
                     {:reply, my_state, my_state}
                  end
                end

              ```

              <aside class="notes">
                <ul>
                  <li>dealt with asynchronous transactions</li>
                  <li>in this case can also deal with synchronous transactions</li>
                </ul>
              </aside>
            </section>

            <section >
              So we just added a block to our peers, but how are the nodes able to receive it?
            </section>

            <section>
              ```elixir

              defmodule Gossip.Server do
                  use GenServer

                ......
                def send_block_chain(new_block_chain, peers) do
                  Enum.map(peers, fn (peer) ->
                    Node.connect(peer)
                    GenServer.cast({__MODULE__, peer}, {:message_from_peer, new_block_chain})
                  end)
                end

                def handle_cast({:message_from_peer, block_chain_message = %{block_chain: blocks},  id: id, uuid: uuid }}, my_state) do
                ...
                    if !Enum.member?(my_state.uuids, block_chain_message.uuid) do
                      case BlockChain.validate_blocks(blocks)  &amp;&amp; length(blocks) > length(me.block_chain)do
                        {:ok, true} ->
                          updated_blocks = BlockChain.swap_chain(blocks)
                          me = %{me | block_chain: blocks}
                          my_state = %{my_state | me: me, uuids: uuids}

                          send_block_chain(me, Node.list)
                          {:noreply, my_state}
                      ...
                    end
                  end
                end
              ```

              <aside class="notes">
                <ul>
                  so again gen server provides us a really nice interface for sending and receiving messages, that makes this message passing easy
                </ul>
                <ul>one important thing to note here </ul>
                <ul>one of the block chain works by a concencus algorithm</ul>
              </aside>
            </section>

            <section>
              Fork Choice rule

              <h2>Message passing</h2>
              <img src="lib/images/process_message_passing.png" style="width: 500px; margin-top: 17px; margin-bottom: 0px;" />
               <div class="credit" style="padding-right: 226px; padding-bottom: 15px;">credit: http://benjamintan.io/blog/2013/06/25/elixir-for-the-lazy-impatient-and-busy-part-2-processes-101/</div>
               <aside class="notes">
                 <ul>
                   <li>
                     the consensus algorithm that Satoshi invented was called the fork choice rule
                   </li>
                   <li>
                     you are a node mining a blokc chain, once you hear of a node on height h, you reject all blockcahins less than ehight h, adn start mining on that chain
                   </li>
                   <li>I will also respect teh first chain I hear about</li>
                   <li>
                     this makes it very hard to douvle spend
                   </li>
                   <li>so when our nodes are minnig blocks, if they receive a chian that is longer than their's they will switch to minnig the longer chain</li>
                 </ul>
               </aside>

            </section>

            <section>
              ```elixir

                defmodule Gossip.Server do
                    use GenServer

                def init(_) do
                    schedule_send_message()
                    {:ok, %{ me: %{id: self(), block_chain: []}, uuids: []}}
                  end
                end

                def handle_info(:schedule_send_message, state) do
                  send_message()
                  schedule_send_message()
                  {:noreply, state}
                end



                defp schedule_send_message do
                  Process.send_after(self(), :schedule_send_message, 30000) # In 30 seconds
                end

              ```

              <aside class="notes">
                <ul> handle info callback is used to handle all other messages. Allowing us to implement this times interval behavior</ul>
              </aside>
            </section>


            <section>
              and to keep an eye on this process we use another supervisor
            </section>

            <section>
              ```elixir
                defmodule Gossip.Application do
                  use Application
                  use Supervisor

                  def start(_type, _args) do
                    Supervisor.start_link([{Gossip.Server, []}, {Gossip.BlockChain, []}], strategy: :one_for_one, name: Gossip.Supervisor)
                  end
                end
              ```
            </section>

            <section>
              Distributed Elixir

              <aside class="notes">
                so we talk about a distrbuted netwrok, but how do we actually communicate
              </aside>
            </section>

            <section>
              ```
                  def send_block_chain(new_block_chain, peers) do
                    Enum.map(peers, fn (peer) ->

                      Node.connect(peer)
                      GenServer.cast({__MODULE__, peer}, {:message_from_peer, new_block_chain})
                    end)
                  end
              ```

              <aside class="notes">
                <ul>Node.connect allows you to create a connectiosn to a peer node by passing in teh peer address</ul>
                <ul>if  you connect node 1 to 2, adn 3, 2 nad 3 will know about each other</ul>
                <ul>there is a way to turn this off if it si not desired</ul>
                <ul>just as easy to connect on disributed machines. Erlang Uses TCP/IP protocol</ul>
              </aside>
            </section>

            <section>
              ```bash
                iex --name anna1@ip --cookie pb -S mix
              ```

              <aside class="notes">
                <ul>
                  <li>
                    connecting with this name with my ip provides an adress for other nodes not on my machine to connect
                  </li>
                  <li>
                    address in name at host.name - on your machine you can use snmaes which don't require an ip, but acorss machins a
                    full name is necessary
                  </li>
                  <li>
                    the cookies are authenitcation built in at the lowers levels - when nodes connect they compare the cookie, if they don't match the connection is afalse
                  </li>
                </ul>
              </aside
              >
            </section>

            <section>
              Live Demo Time (that's always a good ide aright?)
            </section>



              <aside class="notes">
                  <ul>
                      <li>When we think about how to build concurrent applications, and how to deal with monitorin, and timeouts etc, adn servers, there are things to think about.</li>
                      <li>OTP framework takes care of this by grouping these essential practices into a set of libraries that have been carefully engineered and battle-hardened over years.</li>
                      <li>The OTP framework is also a set of modules and standards designed to help you build applications. </li>
                  <ul>
              </aside>
          </section>
        <section>
          <h3>Distributed Networks</h3>h3>

          <aside class="notes">
              <div>Open Telecom Platform</div>

            </aside>
        </section>



          <section class="center" data-background-color="#025A6E">
            <div>Thank you!</div>
            <p style="font-size: 30px">@ANeyzb • anna@carbonfive.com • elixirbridge.org • @elixirbridge </p>
          </section>
          </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
</body>

</html>
